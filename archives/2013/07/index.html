<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>归档：2013/7 | Peng's Blog</title>
  <meta name="author" content="Peng Feixiang">
  
  <meta name="description" content="Hello everyone">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="Peng's Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="Peng's Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>
  
</head>


<body>
  <div id="container" class="container">
    <header id="sidebar" role="banner" class="sidebar"><div id="branding" class="branding">
  <a href="/">
    <img class="circle" src="/img/koala.jpg" alt="Anthem">
  </a>
  <h1 id="site-title" class="title">
    <a href="/">Peng's Blog</a>
  </h1>
</div>
<a href="#" id="toggle">信息</a>
<div class="about" style="display: none">
  <p></p>
</div>
<nav class="menu-navigation-container">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
  </ul>
</nav>
<div class="widget">
  
  <nav class="search">
  <form action="http://google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:fedoral.github.io/">
  </form>
</nav>

  

  
<nav class="tags">
  <h3 class="title">标签</h3>
  <ul>
  
    <li><a href="/tags/DMM/">DMM</a>&nbsp;<small>(9)</small></li>
  
    <li><a href="/tags/hadoop/">hadoop</a>&nbsp;<small>(1)</small></li>
  
  </ul>
</nav>


  <nav class="other">
  <ul>
    <li>
      <a href="http://weibo.com/xiaoguizi1314" target="_blank">关注我的微博</a>
    </li>
  </ul>
</nav>

</div></header>
    <section id="content" class="blog">
      
<h2 class="archive-title">2013/7</h2>


  
    <article class="post">
  <header>
    
  
    <h1 class="title"><a href="/2013/07/16/keepalived-rst/">keepalived RST</a></h1>
  

    
  </header>
  <section class="entry">
    
      <h2>keepalived RST报文</h2>
<h3>keepalived</h3>
<p>假定keepalived服务器是<code>192.168.1.1</code>，http服务器是<code>192.168.1.183</code>.</p>
<p>启动keepalived后，从<code>192.168.1.1</code>或<code>192.168.1.183</code>上抓包可以看到很多<code>192.168.1.1</code>到<code>192.168.1.183</code>的<code>[RST ACK]</code>报文，6秒一个。</p>
<blockquote>
<p><strong>16:09:08</strong>.981844 IP 192.168.1.1.34318 &gt; 192.168.1.183.http: Flags [S], seq 108636079, win 14600, options [mss 1460,sackOK,TS val 250265385 ecr 0,nop,wscale 7], length 0</p>
<p><strong>16:09:08</strong>.982003 IP 192.168.1.183.http &gt; 192.168.1.1.34318: Flags [S.], seq 2574714220, ack 108636080, win 14480, options [mss 1460,sackOK,TS val 1724897103 ecr 250265385,nop,wscale 7], length 0</p>
<p><strong>16:09:08</strong>.982020 IP 192.168.1.1.34318 &gt; 192.168.1.183.http: Flags [.], ack 1, win 115, options [nop,nop,TS val 250265385 ecr 1724897103], length 0</p>
<p><strong>16:09:08</strong>.982096 IP 192.168.1.1.34318 &gt; 192.168.1.183.http: <strong>Flags [R.]</strong>, seq 1, ack 1, win 115, options [nop,nop,TS val 250265385 ecr 1724897103], length 0</p>
<p><strong>16:09:14</strong>.982592 IP 192.168.1.1.34320 &gt; 192.168.1.183.http: Flags [S], seq 2384928787, win 14600, options [mss 1460,sackOK,TS val 250271386 ecr 0,nop,wscale 7], length 0</p>
<p><strong>16:09:14</strong>.982733 IP 192.168.1.183.http &gt; 192.168.1.1.34320: Flags [S.], seq 1294088960, ack 2384928788, win 14480, options [mss 1460,sackOK,TS val 1724903103 ecr 250271386,nop,wscale 7], length 0</p>
<p><strong>16:09:14</strong>.982750 IP 192.168.1.1.34320 &gt; 192.168.1.183.http: Flags [.], ack 1, win 115, options [nop,nop,TS val 250271386 ecr 1724903103], length 0</p>
<p><strong>16:09:14</strong>.982826 IP 192.168.1.1.34320 &gt; 192.168.1.183.http: <strong>Flags [R.]</strong>, seq 1, ack 1, win 115, options [nop,nop,TS val 250271386 ecr 1724903103], length 0</p>
</blockquote>
<p>这是keepalived的健康检查机制，192.168.1.1会定期（默认6秒）向192.168.1.183发送一个TCP连接来检测http是否正常，为了减少TCP连接带来的资源浪费，检测（TCP三次握手）完毕后会发送一个RST报文来断开这个连接，释放资源。</p>
<p>如果业务服务器不是http，有时会在业务服务器日志里还会看到类似<a href="http://nginx.2469901.n2.nabble.com/Keep-alive-connection-errors-in-my-logs-td3385507.html"><code>connection reset by peer</code></a>的日志。</p>
<h3>RST报文</h3>
<p>当服务器close一个连接时，若client端接着发数据。根据TCP协议的规定，会收到一个<code>RST</code>响应，进程对接收了RST的socket发送数据时，内核会发出一个<code>SIGPIPE</code>信号给进程。根据信号的默认处理规则SIGPIPE信号的默认执行动作是<strong>终止进程</strong>,所以client会<strong>退出</strong>。若不想client退出可以把SIGPIPE设为<code>SIG_IGN</code>，如: <code>signal(SIGPIPE,SIG_IGN);</code>，这时SIGPIPE交给了系统处理。参考(1)</p>
<h3>有序释放与异常释放</h3>
<p>终止一个连接的正常方式是一方发送FIN，这被称为有序释放（orderly release），因为在所有排队数据已发送之后才发送FIN。但也有可能发送一个复位报文段而不是FIN来中途释放一个连接，有时称这为异常释放（abortive release）。</p>
<p>异常终止一个连接对应用程序来说有两个优点：</p>
<ol>
<li>丢弃任何待发数据并立即发送复位报文段；</li>
<li>RST的接收方会区分另一端执行的是异常关闭还是正常关闭。应用程序使用的
API必须提供产生异常关闭而不是正常关闭的手段。参考(2)</li>
</ol>
<h3>用有序释放来代替异常释放</h3>
<p>根据TCP协议，主动发起关闭的一方，会进入TIME_WAIT状态，持续2*MSL(Max Segment Lifetime)，缺省为240秒（？ RFC建议120秒，berkeley 实现30秒）。</p>
<p><img src="http://tech.ccidnet.com/pub/attachment/2004/8/322252.png" alt=""></p>
<p>一般来说服务器执行被动关闭，服务器不会进入TIME_WAIT状态。在Keepalived Server+ Real Server中 Server中Keepalived Server充当客户端主动发起关闭。两种方式：（1）关闭的时候使用RST的方式
（2）对处于TIME_WAIT状态的TCP允许重用。当前Keepalived 就被设计成使用RST关闭。</p>
<p>如果使用有序释放代替RST报文，Keepalived + NAT方式中，所有从Keepalived Server 到 Real Server的IP包的 source address都是一样的(对内地址）。TCP连接建立和关闭，会在Keepalived Server上留下TIME_WAIT状态，根据TIME_WAIT黑名单规则，Keepalived Server在240秒内不能再使用此端口建立和Real Server的连接。这样对于一个Real server 假定6秒检查一次，则需要240/6=40个端口来独占使用。对于有60000端口的Keepalived Server来说，可以支撑1000+的Real Server。</p>
<p>至于“对处于TIME_WAIT状态的TCP允许重用”，这种做法不建议使用，无非是减少端口的使用。更好的做法是减小MSL。</p>
<h3>使用TCP的KeepAlive机制</h3>
<p>很多应用层协议都有HeartBeat机制，通常是客户端每隔一小段时间向服务器发送一个数据包，通知服务器自己仍然在线，并传输一些可能必要的数据。使用心跳包的典型协议是IM，比如QQ/MSN/飞信等协议。</p>
<p>TCP的KeepAlive 是更低层次的“心跳检测”机制，主要为探测长连接的存活状况。默认如果一个给定的连接在两小时内没有任何的动作，则服务器就向客户发一个探测报文段，客户主机必须处于以下4个状态之一：</p>
<blockquote>
<p>客户主机依然正常运行，并从服务器可达。客户的TCP响应正常，而服务器也知道对方是正常的，服务器在两小时后将保活定时器复位。</p>
<p>客户主机已经崩溃，并且关闭或者正在重新启动。在任何一种情况下，客户的TCP都没有响应。服务端将不能收到对探测的响应，并在75秒后超时。服务器总共发送10个这样的探测 ，每个间隔75秒。如果服务器没有收到一个响应，它就认为客户主机已经关闭并终止连接。</p>
<p>客户主机崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。</p>
<p>客户机正常运行，但是服务器不可达，这种情况与第二种类似，TCP能发现的就是没有收到探查的响应。</p>
</blockquote>
<p>TCP的KeepAlive功能开启需要做一些配置。参考<a href="http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/#codeneeding">这里</a>，包括了KeepAlive的介绍、相关内核参数、C编程接口、如何为现有应用（可以或者不可以修改源码的）启用KeepAlive机制。</p>
<h3>总结</h3>
<p>使用TCP的KeepAlive机制，对Keepalived的调整会很大，大量代码修改。个人倾向“ 用有序释放来代替异常释放”，释放过程虽然不如RST方式简单明了，但性能可以接受，代码相对来说好修改一些。</p>
<h3>扩展阅读</h3>
<p><a href="http://rdc.taobao.com/blog/cs/?p=1055">tcp连接closse时协议栈发出rst报文, 而不是fin</a></p>
<h3>参考来源</h3>
<p>(1)<a href="http://blog.chinaunix.net/uid-192452-id-3279122.html"><a href="http://blog.chinaunix.net/uid-192452-id-3279122.html">http://blog.chinaunix.net/uid-192452-id-3279122.html</a></a></p>
<p>(2)TCP/IP 详解卷一：协议 p187</p>

    
  </section>
  <footer>
    
    <div class="clearfix"></div>
    
      <div class="alignleft widget">
        
        
          <time datetime="2013-07-16T03:29:50.000Z"><a href="/2013/07/16/keepalived-rst/">7月 16 2013</a></time>
        
        
        
      </div>
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  
    <article class="post">
  <header>
    
  
    <h1 class="title"><a href="/2013/07/11/learn-mapreduce/">Learn MapReduce</a></h1>
  

    
  </header>
  <section class="entry">
    
      <h1>MapReduce: 分布式计算框架</h1>
<p><a href="http://en.wikipedia.org/wiki/MapReduce">维基百科</a>中对MapReduce这样描述——&quot;<strong>MapReduce is a programming model for processing large data sets with a parallel, distributed algorithm on a cluster</strong>.&quot;
MapReduce的名字由函数式编程中常用的map和reduce两个单词组成。2004年Google公司的Jeffrey Dean 和 Sanjay Ghemawat在论文<a href="http://research.google.com/archive/mapreduce.html">MapReduce: Simplified Data Processing on Large Clusters</a>首次提出了MapReduce的思想。</p>
<p>MapReduce被广泛地应用于日志分析、海量数据排序、在海量数据中查找特定模式等场景中。Apache下的Hadoop项目是根据Google论文所实现的一个MapReduce框架。</p>
<h3>MapReduce</h3>
<ul>
<li>优点：可在段时间内完成大量工作。</li>
<li>缺点：算法必须经过重写，需要对系统工程有一定的了解。</li>
<li>适用数据类型：数值型和标称型。</li>
</ul>
<h2>工作流程</h2>
<p>MapReduce 在大量节点组成的集群上运行。它的工作流程是：单个作业被分成很多小份，输入数据也被切片(split)分发到每个节点，各个节点只在本地数据上做运算，对应的运算代码称为mapper，这个过程被称为map阶段。每个mapper的输出通过某种方式组合（一般还会做排序）。排序后的结果再被分成小份分发到各个节点进行下一步的工作，对应的运算代码称为reducer，此过程被称为reduce阶段。reducer的输出就是程序的最终执行结果。</p>
<p><img src="/img/mapreduce.png" alt="image"></p>
<ul>
<li>主节点控制MapReduce的作业流程。</li>
<li>MapReduce的作业可以分为map任务和reduce任务。</li>
<li>map任务之间不做数据交流，reduce任务也一样。</li>
<li>map和reduce阶段中间，有一个sort或combine</li>
<li>数据被重复存放在不同的机器上，以防某个机器失效。</li>
<li>mapper和reducer传输的数据形式为key/value对。</li>
</ul>
<p>（论文学习待补充……）</p>
<h2>参考</h2>
<ul>
<li><a href="http://www.manning.com/pharrington/">Machine Learning in Action</a></li>
</ul>
<h2>拓展阅读</h2>
<ul>
<li><a href="http://www.pgsqldb.org:8079/mwiki/index.php/MapReduce:_%E4%B8%80%E4%B8%AA%E5%B7%A8%E5%A4%A7%E7%9A%84%E5%80%92%E9%80%80">MapReduce: 一个巨大的倒退</a></li>
</ul>

    
  </section>
  <footer>
    
    <div class="clearfix"></div>
    
      <div class="alignleft widget">
        
        
          <time datetime="2013-07-11T13:56:17.000Z"><a href="/2013/07/11/learn-mapreduce/">7月 11 2013</a></time>
        
        
        
  
  <a href="/tags/hadoop/">#hadoop</a>

      </div>
      
    
    <div class="clearfix"></div>
  </footer>
</article>


  

  

    </section>
    <footer id="footer" class="clearfix footer"><div class="alignleft">
  
  &copy; 2013 Peng Feixiang
  
</div>
<div class="clearfix"></div></footer>
  </div>
  <script src="http://lib.sinaapp.com/js/jquery/1.9.0/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/main.js"></script>




<link rel="stylesheet" type="text/css" href="/fancybox/jquery.fancybox.css">
<script type="text/javascript" src="/fancybox/jquery.fancybox.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox({
    prevEffect: 'none',
    nextEffect: 'none',
    closeBtn: false,
    helpers: {
        title: {type: 'inside'},
        buttons: {
            position: 'bottom'
        }
    }
  });
})(jQuery);
</script>

</body>
</html>